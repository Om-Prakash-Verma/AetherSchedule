
AetherSchedule - Documentation: Frontend Architecture
=====================================================

This document outlines the architecture of the AetherSchedule React frontend, covering state management, component structure, styling, and core principles.

---
### 1. Entrypoint and Providers (`index.tsx`)
---

The application's entrypoint is `src/index.tsx`. It sets up all the top-level context providers that wrap the entire application. This ensures that any component can access necessary global state or functionality.

- **`QueryClientProvider`**: From TanStack Query. It provides a client instance for managing all server state (fetching, caching, mutations).
- **`ToastProvider`**: A custom context for displaying "toast" notifications (e.g., "Save successful").
- **`ConfirmProvider`**: A custom context for showing confirmation modals (e.g., "Are you sure you want to delete?").
- **`AppProvider`**: The main application context, responsible for global UI state like the current user, sidebar status, and application-wide settings.

---
### 2. Root Component and Routing (`App.tsx`)
---

`src/App.tsx` is the root component that determines which page to render.

- **Authentication Logic**: It first checks for a `user` object in the `AppContext`.
  - If no user exists, it renders the public-facing pages (`Homepage`, `HowItWorks`, `LoginPage`).
  - If a user exists, it renders the main application `Layout` with the authenticated pages.

- **Code Splitting**: All authenticated pages (`Dashboard`, `Scheduler`, etc.) are lazy-loaded using `React.lazy()`. This means the code for these pages is only downloaded when the user navigates to them, improving the initial load time of the application. The `<Suspense>` component with a `<PageLoader>` fallback handles the loading state.

- **Error Handling**: A dedicated error screen is shown if `appInitializationError` is present in the `AppContext`, which occurs if the initial connection to the backend fails. This provides a better user experience than a blank screen.

---
### 3. State Management
---

AetherSchedule uses a two-pronged approach to state management, separating UI state from server state.

- **`AppContext` (Global UI State)**:
  - **Location**: `src/context/AppContext.tsx`
  - **Purpose**: Manages state that is global, client-side, and affects the UI shell.
  - **Responsibilities**:
    - `user`: The currently logged-in user object.
    - `currentPage`: The active page, used for highlighting the navigation.
    - `isSidebarOpen`, `isSidebarCollapsed`: Controls the state of the navigation sidebar.
    - `timeSlots`, `workingDays`: Derived from timetable settings, these are used throughout the app to render grids consistently.

- **TanStack Query (Server State)**:
  - **Purpose**: Manages all data that comes from the backend. It is the single source of truth for server data.
  - **Usage**:
    - **`useQuery`**: Used for fetching data (e.g., `api.getSubjects()`). It handles caching, background refetching, and stale-time management automatically. This significantly improves performance and reduces redundant API calls. See `DataManagement.tsx` for many examples.
    - **`useMutation`**: Used for creating, updating, or deleting data (e.g., `api.saveSubject()`). It handles the loading/error states of the mutation and provides hooks (`onSuccess`, `onError`) to perform side effects, like invalidating cached queries to refetch data automatically.

- **`useUndoRedo` (Local Complex State)**:
  - **Location**: `src/hooks/useUndoRedo.ts`
  - **Purpose**: Provides undo/redo functionality for complex local state.
  - **Usage**: Used in the `Scheduler.tsx` page to manage the `editedTimetable` state. When a user makes a change (like dragging a class), a new state is pushed to a history stack. This allows the user to undo/redo their manual edits before saving.

---
### 4. Component Structure
---

- **`src/pages/`**: Contains top-level components, each representing a distinct page or view. These components are responsible for fetching data for that page and laying out the UI by composing smaller components.

- **`src/components/`**: Contains reusable components used across multiple pages.
  - **`Layout.tsx`**: The main application shell, including the `Sidebar` and `Header`.
  - **`GlassPanel.tsx`, `GlassButton.tsx`**: Core components of the "glassmorphism" design system. They encapsulate the background, border, and blur styles.
  - **`DataTable.tsx`**: A generic, reusable table component for displaying data with sorting, editing, and deleting capabilities.
  - **`DataFormModal.tsx`**: A highly versatile modal component that renders different form fields based on the `dataType` prop. It handles creating and editing for almost all data types in the app.

- **`src/components/ui/`**: Contains smaller, highly reusable UI primitives, often wrappers around third-party libraries or custom-built elements like modals and selects.
  - **`Modal.tsx`**: A generic, accessible modal component.
  - **`GlassSelect.tsx` / `MultiSelectDropdown.tsx`**: Custom select components that use the `SelectionModal` to provide a consistent, searchable, and mobile-friendly selection experience.

---
### 5. Styling
---

- **Tailwind CSS**: The primary tool for styling. It's used for layout, typography, colors, and most other styling needs directly within the component files. The configuration is standard.

- **`styles.css`**: This file contains global styles and CSS variables.
  - **CSS Custom Properties (Variables)**: All colors, fonts, and major layout values are defined as CSS variables (e.g., `--bg`, `--accent`, `--panel`). This allows for easy theming and consistent design. The dark theme is defined here.
  - **Global Styles**: Base styles for `body`, `html`, custom scrollbars, and text selection are defined here.
  - **Animations**: Custom `@keyframes` animations (like `fade-in-up`, `pulse-danger`) are defined here and applied via utility classes.
